
<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.19: https://docutils.sourceforge.io/" />

  <title>Quick Sort</title>
    <link rel="stylesheet" type="text/css" href="../_static/revealjs4/dist/reveal.css" />
    <link rel="stylesheet" href="../_static/custom.css" type="text/css" />
    <link rel="stylesheet" type="text/css" href="../_static/revealjs4/plugin/highlight/zenburn.css" />
    <script async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

  </head><body>
    <div class="reveal">
        <div class="slides" role="main">
            <section >
<h1>Quick Sort</h1>
<ul class="simple">
<li><p>By Sir Tony Hoare in 1959.</p></li>
<li><p>One of the most widely used</p></li>
<li><p>Characteristics</p>
<ul>
<li><p>Divide and conquer algorithm</p></li>
<li><p>Comparison based (general purpose)</p></li>
<li><p>Recursive</p></li>
<li><p>In-place</p></li>
<li><p>Efficient</p></li>
<li><p>Unstable - relative order of equal elements is not preserved</p></li>
</ul>
</li>
</ul>
</section>
<section >
<h2>Quick partition algorithm</h2>
<ul class="simple">
<li><p>The core of quick sort</p></li>
<li><p>Many variations: <strong>Use our variation of Hoare’s partition scheme to keep
everything consistent!</strong></p></li>
<li><p>Steps</p>
<ol class="arabic simple">
<li><p>Pick an element, called a pivot, from the list.</p></li>
<li><p>Use the pivot to partition the list into two sublists.</p></li>
<li><p>Reorder the list in the process so that all elements less than the pivot
come before the pivot, and all elements greater than the pivot come
after it.</p></li>
<li><p>Return the <strong>location of the partition.</strong></p></li>
</ol>
</li>
<li><p>Select the pivot</p>
<ul>
<li><p>First element as pivot</p></li>
<li><p>Middle element as pivot</p></li>
<li><p>Random element as pivot</p></li>
</ul>
</li>
</ul>
</section>
<section >
<h2>Quick Partition Algorithm: Our Variation (Hoare’s Scheme)</h2>
<ul class="simple">
<li><p>Lomuto’s partition scheme (FYI)</p></li>
<li><p>Hoare’s partition scheme (Our variation)</p>
<ol class="arabic simple">
<li><p>Let two cursor indices to point to the first and last element of the
list respectively.</p></li>
<li><p>Move the left cursor to the right until it points to an element
<strong>greater and equal</strong> than the pivot.</p></li>
<li><p>Move the right cursor to the left until it points to an element <strong>less
and equal</strong> than the pivot.</p></li>
<li><p>If the left cursor meets the right cursor, the partition is complete.
Return the left or right cursor.</p></li>
<li><p>Swap the elements pointed by the two cursors.</p></li>
<li><p>Repeat steps 2-5 until the partition is complete (step 4 returns).</p></li>
</ol>
</li>
</ul>
</section>
<section >
<h2>Quick Partition Algorithm: Our Variation (Hoare’s Scheme)</h2>
<ul class="simple">
<li><p>Hoare’s partition scheme</p></li>
<li><p>Middle element as pivot</p></li>
<li><p><strong>Cursor will not pass by the pivot, so the pivot will be swapped many
times.</strong></p></li>
<li><p>The returned index is the final position of the pivot</p></li>
</ul>
<pre data-id="id1"><code data-trim data-noescape class="default">function hoare_partition(arr, low, high):
  // Select the middle element as the pivot
  middle = (low + high) / 2  // integer division
  pivot = arr[middle]

  i = low
  j = high

  while True:
    // Find leftmost element greater than or equal to pivot
    while arr[i] &lt; pivot:
      i = i + 1

    // Find rightmost element less than or equal to pivot
    while arr[j] &gt; pivot
      j = j - 1

    // If pointers meet, partition is complete
    if i == j:
      return i  // Return the index

    swap(arr[i], arr[j])</code></pre>
</section>
<section >
<h2>Quick Partition Example (con’d)</h2>
<ul>
<li><p>Given an int array <code class="docutils literal notranslate"><span class="pre">{42,</span> <span class="pre">7,</span> <span class="pre">85,</span> <span class="pre">23,</span> <span class="pre">64,</span> <span class="pre">91,</span> <span class="pre">9,</span> <span class="pre">73,</span> <span class="pre">18,</span> <span class="pre">56}</span></code></p></li>
<li><p>First round of partitioning</p>
<pre><code data-trim data-noescape class="text">// low is 0, high is 9 initially
middle = (low + high) / 2 = 4
pivot = arr[middle] = 64

{42, 7, 85, 23, 64, 91, 9, 73, 18, 56} swap 85, 56
        l                          h
{42, 7, 56, 23, 64, 91, 9, 73, 18, 85} swap 64, 18
                l              h
{42, 7, 56, 23, 18, 91, 9, 73, 64, 85} swap 91, 64
                    l          h
{42, 7, 56, 23, 18, 64, 9, 73, 91, 85} swap 64, 9
                    l   h
{42, 7, 56, 23, 18, 9, 64, 73, 91, 85} return 6
                       lh</code></pre>
</li>
<li><p>All elements to the left of the returned index are less than or equal to the
pivot, and all elements to the right of the returned index are greater than
or equal to the pivot. <strong>The pivot is already in its final position.</strong></p></li>
<li><p>The returned index is the final position of the pivot.</p></li>
<li><p><strong>Exercise:</strong></p>
<ul class="simple">
<li><p>Next round of partitioning on the left and right sublists.</p></li>
<li><p>How about the first element is selected as the pivot? Is there more
movement of data?</p></li>
</ul>
</li>
</ul>
</section>
<section >
<h2>Quick Sort Algorithm</h2>
<ul class="simple">
<li><p>Recursive</p></li>
<li><p>In-place</p></li>
<li><p>Need a helper function to work on a sublist</p>
<ol class="arabic simple">
<li><p>If the range is empty, return.</p></li>
<li><p>Call quick partition algorithm to partition the list into two sublists.</p></li>
<li><p>Recursively call quick sort on both sublists.</p></li>
</ol>
</li>
</ul>
<pre data-id="quick-sort-algorithm"><code data-trim data-noescape class="default">function quick_sort(arr, size):
  quick_sort_helper(arr, 0, size - 1)

function quick_sort_helper(arr, low, high):
  if low &gt;= high:
    return

  // Partition the list into two sublists
  partition_index = hoare_partition(arr, low, high)

  // Recursively call quick sort on both sublists
  // The pivot is already in its final position
  quick_sort_helper(arr, low, partition_index - 1)
  quick_sort_helper(arr, partition_index + 1, high)</code></pre>
</section>
<section >
<h2>Complexity</h2>
<ul class="simple">
<li><p>Time</p>
<ul>
<li><p>Depends on whether the pivot can partition the list into two sublists
of roughly equal size</p></li>
<li><p><span class="math notranslate nohighlight">\(\Theta(n \log n)\)</span> average case</p></li>
<li><p><span class="math notranslate nohighlight">\(\Theta(n^2)\)</span> worst case, extremely uneven partitioning</p></li>
</ul>
</li>
<li><p>Space - <span class="math notranslate nohighlight">\(\Theta(1)\)</span></p></li>
<li><p>Improvement attempts</p>
<ul>
<li><p>Pivot selection</p>
<ul>
<li><p>Randomized quick sort</p></li>
<li><p>Median of medians</p></li>
</ul>
</li>
<li><p>Shuffling the list before sorting</p></li>
</ul>
</li>
</ul>
</section>
<section >
<h2>Visualization For Quick sort</h2>
<p>Unfortunately, the visualization websites are all using different
configurations and are not compatible with our demonstration.</p>
<ul class="simple">
<li><p>Some of them uses Lomuto’s scheme</p>
<ul>
<li><p><a class="reference external" href="http://me.dt.in.th/page/Quicksort/">http://me.dt.in.th/page/Quicksort/</a></p></li>
<li><p><a class="reference external" href="https://www.toptal.com/developers/sorting-algorithms/quick-sort">https://www.toptal.com/developers/sorting-algorithms/quick-sort</a></p></li>
<li><p><a class="reference external" href="https://visualgo.net/en/sorting">https://visualgo.net/en/sorting</a></p></li>
</ul>
</li>
<li><p>Some of them uses Hoare’s scheme but select a different pivot</p>
<ul>
<li><p><a class="reference external" href="http://www.cs.usfca.edu/~galles/visualization/ComparisonSort.html">http://www.cs.usfca.edu/~galles/visualization/ComparisonSort.html</a></p></li>
</ul>
</li>
<li><p>The zybook example uses Hoare’s scheme and the middle element as the pivot
but allow the pivot to be passed by the cursor.</p></li>
</ul>
</section>

        </div>
    </div>
    
    <script src="../_static/revealjs4/dist/reveal.js"></script>
    
    
      <script src="../_static/revealjs4/plugin/notes/notes.js"></script>
      <script src="../_static/revealjs4/plugin/highlight/highlight.js"></script>
      <script src="../_static/revealjs4/plugin/math/math.js"></script>
      
    
    <script>
        var revealjsConfig = new Object();
        Object.assign(revealjsConfig, JSON.parse('{"controls": true, "progress": true, "hash": true, "center": true, "transition": "slide", "slideNumber": true}'));
        
        
        
          revealjsConfig.plugins = [
            RevealNotes,RevealHighlight,RevealMath,
          ];
        
        // More info https://github.com/hakimel/reveal.js#configuration
        Reveal.initialize(revealjsConfig);
    </script>

  </body>
</html>