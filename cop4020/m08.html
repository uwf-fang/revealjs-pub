<!DOCTYPE html>

<html lang="en" data-content_root="../">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

  <title>Programming Languages</title>
    <link rel="stylesheet" type="text/css" href="../_static/revealjs/dist/reveal.css?v=40f0a724" />
    <link rel="stylesheet" href="../_static/custom.css" type="text/css" />
    <link rel="stylesheet" type="text/css" href="../_static/idea.css?v=e717f371" />
    <link rel="stylesheet" type="text/css" href="../_static/graphviz.css" />
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

  </head><body>
    <div class="reveal">
        <div class="slides" role="main">
            <section >
<section data-background-color="white" data-background-image="../_static/logo.png" data-background-size="50%" data-background-position="top center" data-background-repeat="no-repeat">
<h1>Programming Languages</h1>
<div class="subtitle docutils container">
<p><strong>Module 8: subprograms</strong></p>
<p>Xingang (Ian) Fang</p>
</div>
</section>
</section>
<section >
<section >
<h2>Subprograms</h2>
<ul class="simple">
<li><p>Introduction</p></li>
<li><p>Parameter-passing methods</p></li>
<li><p>Dynamic invocation of subprograms</p></li>
<li><p>Generic subprograms</p></li>
<li><p>Closures and coroutines</p></li>
</ul>
</section>
</section>
<section >
<section >
<h2>Introduction</h2>
<ul class="simple">
<li><p>Core concept in programming languages for process abstraction</p>
<ul>
<li><p>Counter part to data abstraction</p></li>
</ul>
</li>
<li><p>Building blocks for modular program design</p></li>
<li><p>Key topics:</p>
<ul>
<li><p>Parameter passing methods</p></li>
<li><p>Local referencing environments</p></li>
<li><p>Overloaded and generic subprograms</p></li>
<li><p>Closures and coroutines</p></li>
</ul>
</li>
</ul>
</section>
<section >
<h3>Fundamentals of Subprograms</h3>
<ul class="simple">
<li><p>Basic Characteristics (with exceptions)</p>
<ul>
<li><p>Single entry point</p></li>
<li><p>Caller suspended during execution</p></li>
<li><p>Control returns to caller on completion</p></li>
</ul>
</li>
<li><p>Components:</p>
<ul>
<li><p>Subprogram definition - interface and actions</p>
<ul>
<li><p>Subprogram header - name, parameters, return type</p></li>
<li><p>Subprogram body - implementation</p></li>
</ul>
</li>
<li><p>Subprogram call - explicit invocation</p></li>
</ul>
</li>
<li><p>Types:</p>
<ul>
<li><p>Procedures - define new statements</p></li>
<li><p>Functions - return values and define new operations</p></li>
</ul>
</li>
</ul>
</section>
<section >
<h3>Parameters</h3>
<ul class="simple">
<li><p>Ways to pass data to/from subprograms</p></li>
<li><p>Parameter Categories:</p>
<ul>
<li><p>Formal parameters - in subprogram definition</p></li>
<li><p>Actual parameters - in subprogram call</p></li>
</ul>
</li>
<li><p>Parameter Association:</p>
<ul>
<li><p>Positional parameters</p></li>
<li><p>Keyword parameters (Python)</p></li>
<li><p>Default parameters (C++, Python)</p></li>
</ul>
</li>
<li><p>Variable Parameters:</p>
<ul>
<li><p>C# params modifier</p></li>
<li><p>Python *args and *kwargs</p></li>
<li><p>Ruby splat operator (*)</p></li>
<li><p>Lua ellipsis (â€¦)</p></li>
</ul>
</li>
</ul>
</section>
<section >
<h3>More Design Issues</h3>
<ol class="arabic">
<li><p>Parameter-passing methods</p></li>
<li><p>Support to nested subprograms</p>
<ul class="simple">
<li><p>Closure - nested subprogram + referencing environment</p></li>
</ul>
</li>
<li><p>Overloaded and generic subprograms</p>
<ul class="simple">
<li><p>Overloaded Subprograms - Same name, different parameter profile</p></li>
<li><p>Generic Subprograms - Type-independent subprograms</p></li>
</ul>
</li>
<li><p>Side effects</p>
<p>Definition: Modification of state outside subprogram. Will discuss more in
functional programming chapter.</p>
<ul class="simple">
<li><p>Functional side effects</p></li>
<li><p>Referential transparency</p></li>
</ul>
</li>
<li><p>Return values</p>
<ul class="simple">
<li><p>type</p></li>
<li><p>number</p></li>
</ul>
</li>
</ol>
</section>
<section >
<h3>Local Referencing Environments</h3>
<ul class="simple">
<li><p>Scope - visibility of identifiers</p></li>
<li><p>Lifetime - duration of identifiers</p></li>
<li><p>Referencing environment - collection of all active bindings</p>
<ul>
<li><p>Local variables</p></li>
<li><p>Formal parameters</p></li>
<li><p>Nested subprograms</p></li>
</ul>
</li>
</ul>
</section>
</section>
<section >
<section >
<h2>Parameter-Passing Methods</h2>
<div class="flex-container docutils container">
<div class="half docutils container">
<ul class="simple">
<li><p>Three Semantics Models:</p>
<ul>
<li><p>In mode - data to subprogram</p></li>
<li><p>Out mode - data from subprogram</p></li>
<li><p>Inout mode - bidirectional</p></li>
</ul>
</li>
<li><p>Implementation Methods:</p>
<ul>
<li><p>Pass-by-value (In mode)</p></li>
<li><p>Pass-by-result (Out mode)</p></li>
<li><p>Pass-by-reference (Inout mode)</p></li>
<li><p>Pass-by-value-result (Inout mode)</p></li>
<li><p>Pass-by-name (Inout mode, FYI)</p></li>
</ul>
</li>
</ul>
</div>
<div class="half docutils container">
<p><strong>C# Example of pass-by-result</strong></p>
<pre><code data-trim data-noescape class="c#">void Fixer(out int x, out int y) {
    x = 17;
    y = 35;
}

f.Fixer(out a, out b);</code></pre>
</div>
</div>
</section>
<section >
<h3>Implementation Considerations</h3>
<ul class="simple">
<li><p>Pass-by-value/result/value-result:</p>
<ul>
<li><p>Copies data</p>
<ul>
<li><p>at call (by-value)</p></li>
<li><p>at return (by-result)</p></li>
</ul>
</li>
<li><p>Safe but expensive for large data</p></li>
</ul>
</li>
<li><p>Pass-by-reference:</p>
<ul>
<li><p>Copies address at call</p></li>
<li><p>Efficient and simple to implement</p></li>
<li><p>Security concerns: aliasing allows modification</p></li>
<li><p>May use use constant/read-only modifiers to improve safety</p></li>
</ul>
</li>
<li><p>Implementation via the run-time stack</p></li>
</ul>
</section>
</section>
<section >
<section >
<h2>Dynamic Invocation Of Subprograms</h2>
<ul class="simple">
<li><p>Dynamic invocation - subprogram called at runtime</p></li>
<li><p>Examples:</p>
<ul>
<li><p>Function pointers in C/C++</p>
<ul>
<li><p><code class="code docutils literal notranslate"><span class="pre">void</span> <span class="pre">(*f)(int)</span></code></p></li>
</ul>
</li>
<li><p>Lambda expression in C++</p>
<ul>
<li><p><code class="code docutils literal notranslate"><span class="pre">auto</span> <span class="pre">f</span> <span class="pre">=</span> <span class="pre">[](int</span> <span class="pre">x)</span> <span class="pre">{</span> <span class="pre">return</span> <span class="pre">x</span> <span class="pre">+</span> <span class="pre">1;</span> <span class="pre">}</span></code></p></li>
</ul>
</li>
<li><p>Reflection in Java/C#</p></li>
<li><p>Interface and lambda expressions in Java</p></li>
<li><p>Method references in Java</p></li>
<li><p>Delegates in C#</p></li>
<li><p>Functions as objects in Python/Ruby/JavaScript</p></li>
</ul>
</li>
</ul>
</section>
<section >
<h3>Passing Subprograms as Parameters</h3>
<ul class="simple">
<li><p>One way of dynamic invocation of subprograms</p></li>
<li><p>Challenges</p>
<ul>
<li><p>Type checking</p></li>
<li><p>Referencing environment of nested subprograms</p>
<ul>
<li><p>Shallow binding</p></li>
<li><p>Deep binding - most common, closures</p></li>
<li><p>Ad hoc binding</p></li>
</ul>
</li>
</ul>
</li>
</ul>
</section>
</section>
<section >
<section >
<h2>Generic Subprograms</h2>
<ul class="simple">
<li><p>Type of polymorphism</p>
<ul>
<li><p>Ad hoc polymorphism - overloading</p></li>
<li><p>Subtype polymorphism - object-oriented</p></li>
<li><p>Parametric polymorphism - generic programming</p></li>
</ul>
</li>
<li><p>Purpose:</p>
<ul>
<li><p>Code reuse across different types</p></li>
<li><p>Type-safe polymorphism</p></li>
</ul>
</li>
<li><p>Implementations of generic subprograms:</p>
<ul>
<li><p>C++ templates</p></li>
<li><p>Java 5.0 generics</p></li>
<li><p>C# 2005 generics</p></li>
<li><p>F# automatic generalization</p></li>
</ul>
</li>
<li><p>Constraints:</p>
<ul>
<li><p>Type restrictions</p></li>
<li><p>Compile-time vs runtime binding</p></li>
</ul>
</li>
</ul>
</section>
<section >
<h3>Closures</h3>
<div class="flex-container docutils container">
<div class="half docutils container">
<p>In static-scope languages, when nested subprograms are passed as parameters, they carry their referencing environment with them.</p>
<ul class="simple">
<li><p>Subprogram + referencing environment</p></li>
<li><p>Used in functional programming</p></li>
<li><p>Support in modern languages</p></li>
</ul>
</div>
<div class="half docutils container">
<p><strong>Python Example of Closures</strong></p>
<pre><code data-trim data-noescape class="python">def outer(x):
    def inner(y):
        return x + y
    return inner

f = outer(5)
print(f(3))  # 8</code></pre>
<p>Do you think there is a better way to implement this?</p>
</div>
</div>
</section>
<section >
<h3>Coroutines</h3>
<div class="flex-container docutils container">
<div class="half docutils container">
<ul class="simple">
<li><p>Very untypical subprograms</p></li>
<li><p>Multiple entry points</p></li>
<li><p>Symmetric control transfer</p></li>
<li><p>Quasi-concurrent execution</p></li>
<li><p>Examples:</p>
<ul>
<li><p>Python generators and async/await</p></li>
<li><p>Go goroutines</p></li>
<li><p>C++20 coroutines</p></li>
<li><p>Ruby fibers</p></li>
<li><p>C# async/await</p></li>
<li><p>JavaScript async/await</p></li>
</ul>
</li>
</ul>
</div>
<div class="half docutils container">
<pre><code data-trim data-noescape class="python">def counter():
    i = 0
    while True:
        yield i
        i += 1

c = counter()
print(next(c))  # 0
print(next(c))  # 1</code></pre>
</div>
</div>
</section>
<section >
<h3>Practice Questions</h3>
<ol class="arabic simple">
<li><p>Compare pass-by-value and pass-by-reference</p></li>
<li><p>When would you use generic subprograms?</p></li>
<li><p>What are the tradeoffs in parameter passing methods?</p></li>
<li><p>How do closures differ from regular subprograms?</p></li>
</ol>
</section>
</section>

        </div>
    </div>
    
    <script src="../_static/revealjs/dist/reveal.js"></script>
    
    
      <script src="../_static/revealjs/plugin/notes/notes.js"></script>
      <script src="../_static/revealjs/plugin/highlight/highlight.js"></script>
      <script src="../_static/revealjs/plugin/math/math.js"></script>
      
    
    <script>
        var revealjsConfig = new Object();
        Object.assign(revealjsConfig, {"controls": true, "progress": true, "hash": true, "center": true, "transition": "slide", "slideNumber": true, "scrollActivationWidth": null});
        
        
        
          revealjsConfig.plugins = [
            RevealNotes,RevealHighlight,RevealMath,
          ];
        
        // More info https://github.com/hakimel/reveal.js#configuration
        Reveal.initialize(revealjsConfig);
    </script>

  </body>
</html>