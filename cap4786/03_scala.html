
<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.19: https://docutils.sourceforge.io/" />

  <title>Introduction to Big Data Analytics</title>
    <link rel="stylesheet" type="text/css" href="../_static/revealjs4/dist/reveal.css" />
    <link rel="stylesheet" href="../_static/custom.css" type="text/css" />
    <link rel="stylesheet" type="text/css" href="../_static/revealjs4/plugin/highlight/zenburn.css" />
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

  </head><body>
    <div class="reveal">
        <div class="slides" role="main">
            <section data-background-color="white" data-background-image="../_static/logo.png" data-background-size="50%" data-background-position="top center" data-background-repeat="no-repeat">
<h1>Introduction to Big Data Analytics</h1>
<div class="subtitle docutils container">
<p><strong>Chapter 2: Programming in Scala</strong></p>
<p>Xingang (Ian) Fang</p>
</div>
</section>
<section >
<h2>Scala Programming Language</h2>
<ul class="simple">
<li><p>General purpose</p></li>
<li><p>Statically typed</p></li>
<li><p>Hybrid paradigm: Object Oriented and Functional</p></li>
<li><p>A Java Virtual Machine (JVM) language</p>
<ul>
<li><p>Interpreted with read-evaluate-print loop (REPL) shell</p></li>
<li><p>Compiled using scalac compiler</p></li>
<li><p>Distributed as a jar file</p></li>
</ul>
</li>
<li><p>Spark is written in Scala</p></li>
</ul>
</section>
<section >
<h2>Scala in this course</h2>
<ul class="simple">
<li><p>My opinion on Scala</p>
<ul>
<li><p>Support to two paradigms makes it powerful but challenging to learn</p></li>
<li><p>Convenient alternative syntax to do the same thing leads to confusion</p></li>
<li><p>Not the best language of choice to learn</p>
<ul>
<li><p>Complex, hard to master</p></li>
<li><p>Not widely used</p></li>
</ul>
</li>
</ul>
</li>
<li><p>Scope in this course</p>
<ul>
<li><p>Learn enough Scala to understand and write Spark code</p>
<ul>
<li><p>write functions efficiently</p></li>
<li><p>conversion between Spark Data APIs to Scala collections</p></li>
<li><p>call Spark and related APIs</p></li>
</ul>
</li>
<li><p>Safe to ignore most of the advanced features</p></li>
</ul>
</li>
</ul>
</section>
<section >
<h2>Topics</h2>
<ul class="simple">
<li><p>Scala shell</p></li>
<li><p><strong>Functional programming</strong></p></li>
<li><p>Syntax basics</p></li>
<li><p>Values, variables, and types</p></li>
<li><p><strong>Functions</strong></p></li>
<li><p>Classes</p></li>
<li><p>Advanced data types</p></li>
<li><p>Other features</p></li>
</ul>
<div class="footnote docutils container">
<p><strong>Bold</strong> topics are essential for Spark programming, while others are
something you can refer to reference material as needed.</p>
</div>
</section>
<section >
<h2>Scala Shell</h2>
<ul class="simple">
<li><p>Scala shell is an interactive shell to run Scala code line by line</p></li>
<li><p>REPL: Read-Evaluate-Print Loop</p></li>
<li><p>Spark shell is an extension of standard Scala shell</p>
<ul>
<li><p>Run <code class="docutils literal notranslate"><span class="pre">spark-shell</span></code> to start Spark shell</p></li>
</ul>
</li>
</ul>
<a class="reference internal image-reference" href="../_images/spark-shell.png"><img alt="../_images/spark-shell.png" src="../_images/spark-shell.png" style="width: 100%;" /></a>
</section>
<section >
<h2>Functional Programming</h2>
<ul class="simple">
<li><p>Functional programming is a programming paradigm</p></li>
<li><p>Characteristics</p>
<ul>
<li><p>Functions are first-class citizens</p>
<ul>
<li><p>like an object</p></li>
<li><p>can be passed as arguments</p></li>
<li><p>can be returned from other functions</p></li>
<li><p>can be assigned to variables</p></li>
</ul>
</li>
<li><p>Functions are composable</p></li>
<li><p>Functions are pure</p>
<ul>
<li><p>Does not depend on anything outside the scope (except parameters):
predicable, reproducible</p></li>
<li><p>Does not change anything out of the scope: <strong>No side effects</strong></p></li>
</ul>
</li>
<li><p>Immutable data: always create a new object rather than modifying the
existing one</p></li>
</ul>
</li>
</ul>
</section>
<section >
<h2>Syntax Basics</h2>
<ul class="simple">
<li><p>Case sensitive</p></li>
<li><p>Statement terminator: semicolon</p></li>
<li><p>Comments syntax same as java: <code class="docutils literal notranslate"><span class="pre">//</span></code> and <code class="docutils literal notranslate"><span class="pre">/*</span> <span class="pre">*/</span></code></p></li>
<li><p>Blocks are enclosed in curly braces</p></li>
<li><p>Many syntax has more convenient alternatives</p>
<ul>
<li><p>Huge source of confusion for beginners!!! Even worse than old version of
JavaScript in my opinion.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">return</span></code>, semicolons, parentheses, dot, etc. can be omitted in many cases</p></li>
<li><p>types can be inferred</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">_</span></code> can be used as a placeholder or wildcard</p></li>
</ul>
</li>
</ul>
</section>
<section>
<section >
<h2>Values, Variables, and Types</h2>
<div class="flex-container docutils container">
<div class="half docutils container">
<ul class="simple">
<li><p>Everything in Scala is an object, no primitive types</p></li>
<li><p>Values</p>
<ul>
<li><p>Immutable</p></li>
<li><p>Declared using <code class="docutils literal notranslate"><span class="pre">val</span></code> keyword</p></li>
</ul>
</li>
<li><p>Variables</p>
<ul>
<li><p>Mutable</p></li>
<li><p>Declared using <code class="docutils literal notranslate"><span class="pre">var</span></code> keyword</p></li>
</ul>
</li>
<li><p>Types</p>
<ul>
<li><p>Scala is statically typed</p></li>
<li><p>Basic types</p></li>
<li><p>advanced types (like tuples, option type, case class, collections, etc)</p></li>
<li><p>Type inference: Scala compiler can infer the type of a variable</p></li>
</ul>
</li>
</ul>
</div>
<div class="half docutils container">
<table class="docutils align-default" id="id1">
<caption><span class="caption-text">Basic Types in Scala</span></caption>
<thead>
<tr class="row-odd"><th class="head"><p>Type</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>Byte</p></td>
<td><p>8-bit signed integer</p></td>
</tr>
<tr class="row-odd"><td><p>Short</p></td>
<td><p>16-bit signed integer</p></td>
</tr>
<tr class="row-even"><td><p>Int</p></td>
<td><p>32-bit signed integer</p></td>
</tr>
<tr class="row-odd"><td><p>Long</p></td>
<td><p>64-bit signed integer</p></td>
</tr>
<tr class="row-even"><td><p>Float</p></td>
<td><p>32-bit floating point number</p></td>
</tr>
<tr class="row-odd"><td><p>Double</p></td>
<td><p>64-bit floating point number</p></td>
</tr>
<tr class="row-even"><td><p>Char</p></td>
<td><p>16-bit Unicode character</p></td>
</tr>
<tr class="row-odd"><td><p>String</p></td>
<td><p>A sequence of characters</p></td>
</tr>
<tr class="row-even"><td><p>Boolean</p></td>
<td><p>true or false</p></td>
</tr>
</tbody>
</table>
</div>
</div>
</section>
<section >
<h3>Value, Variable, and Type Examples</h3>
<pre data-id="value-variable-and-type-examples"><code data-trim data-noescape class="scala">val x: Int = 10
var y: String = &quot;Hello, World!&quot;

val z = 20 // Type inference
var w = &quot;Hello, Scala!&quot; // Type inference

val a: Int = 10
a = 20 // Error: reassignment to val</code></pre>
</section>
</section>
<section>
<section >
<h2>Functions in Scala</h2>
<ul class="simple">
<li><p>Functional programming support</p></li>
<li><p>Functions are first-class citizens</p>
<ul>
<li><p>Functions can be used as objects: as parameter, as return value, as
assigned value</p></li>
<li><p>High-order function: A function that takes another function as an argument</p></li>
</ul>
</li>
<li><p>Flexible syntax to define functions (a drawback in my opinion)</p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">def</span></code> keyword - formal way</p></li>
<li><p>anonymous function (function literal)</p>
<ul>
<li><p>usually used as an actual parameter in a function call</p></li>
</ul>
</li>
<li><p>return keyword is optional</p></li>
<li><p>parentheses are optional for single parameter</p></li>
</ul>
</li>
</ul>
</section>
<section >
<h3>Local Function Definition Using def</h3>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">def</span></code> keyword</p></li>
<li><p>Return type can be inferred</p></li>
<li><p>Returning <code class="docutils literal notranslate"><span class="pre">Unit</span></code> means no return value (like void in Java)</p></li>
<li><p>Return keyword is optional</p></li>
<li><p>Curly braces are optional for single line function</p></li>
<li><p>When calling, parentheses are optional for zero parameter function</p></li>
</ul>
<pre data-id="local-function-definition-using-def"><code data-trim data-noescape class="scala">def print5(): Unit = { println(5) }

print5()
// print5

def square(x: Int): Int = {
  return x * x
}

def square1(x: Int): Int = { x * x }  // return keyword is omitted

def square2(x: Int): Int = x * x  // curly braces are omitted

println(square(10))  // 100</code></pre>
</section>
<section >
<h3>Anonymous Functions (Function Literals)</h3>
<ul class="simple">
<li><p>Anonymous function is a function without a name</p></li>
<li><p>Syntax: <code class="docutils literal notranslate"><span class="pre">(parameters)</span> <span class="pre">=&gt;</span> <span class="pre">expression</span></code></p></li>
<li><p>It can be assigned to a variable</p></li>
<li><p>It can be passed as an argument to another function</p></li>
<li><p>It can be returned from another function</p></li>
<li><p>Underscores can be used as placeholders</p></li>
</ul>
<pre data-id="anonymous-functions-function-literals"><code data-trim data-noescape class="scala">val square = (x: Int) =&gt; x * x  // return type is inferred

val square = x: Int =&gt; x * x

val square : Int =&gt; Int = x =&gt; x * x

// When _ is used, the second =&gt; can be omitted
// Next line does not work because _ * _ suggests that the function should take two arguments
// val square : Int =&gt; Int = _ * _

val add : (Int, Int) =&gt; Int = _ * _</code></pre>
</section>
<section >
<h3>High-order Functions</h3>
<ul class="simple">
<li><p>High-order function: A function that takes another function as an argument</p></li>
</ul>
<pre data-id="high-order-functions"><code data-trim data-noescape class="scala">def compute(f: Int =&gt; Int, x: Int): Int = f(x)

println(compute(square, 10)  // 100, use existing function
println(compute(x =&gt; x * x, 10))  // 100, use anonymous function

// Alternative syntax to define the function
val compute = (f: Int =&gt; Int, x: Int) =&gt; f(x)</code></pre>
</section>
<section >
<h3>Closure</h3>
<ul class="simple">
<li><p>Closure: A function that captures the value/variable from the environment in
which it is defined</p></li>
</ul>
<pre data-id="closure"><code data-trim data-noescape class="scala">val x = 5
val adder = (y: Int) =&gt; x + y  // x is captured from the environment
println(adder(3)) // output is 5 + 3 = 8

// This function returns a function
def makeAdder(x: Int): Int =&gt; Int = {
  // returning a function (closure) that captures the variable 'x'
  y =&gt; x + y
}
val adder = makeAdder(5) // Create a closure that adds 5 to its argument
println(adder(3)) // Output is 5 + 3 = 8</code></pre>
</section>
</section>
<section >
<h2>Scala Classes</h2>
<ul class="simple">
<li><p>Scala is an object-oriented language</p></li>
<li><p>Classes are the blueprint for objects</p></li>
<li><p>Syntax to define a class is like a function (constructor) definition with a
class keyword</p></li>
<li><p>Use <code class="docutils literal notranslate"><span class="pre">new</span></code> keyword to create an instance of a class (an object)</p></li>
<li><p>Methods are defined as inner/nested functions in a class</p></li>
<li><p>dot, parentheses can be omitted when calling a method</p></li>
</ul>
<pre data-id="scala-classes"><code data-trim data-noescape class="scala">class Person(name: String, age: Int) {
  def print(): Unit = {
    println(s&quot;Name: $name, Age: $age&quot;)
  }
}

// p is an instance of the Person class
// p is an object
val p = new Person(&quot;Alice&quot;, 25)
p.print()  // Name: Alice, Age: 25
// p print()
// p print</code></pre>
</section>
<section >
<h2>Scala Objects</h2>
<ul class="simple">
<li><p>Objects are instances of classes or singletons (unique in scala)</p></li>
<li><p>We focus on singleton here</p></li>
<li><p>Singleton can be considered a class with only one instance or a standalone
object</p></li>
<li><p>Syntax to define a singleton is like a class definition with an object
keyword</p></li>
<li><p>A special singleton object is used with a main method to serve as an entry
point for the application</p></li>
</ul>
<pre data-id="scala-objects"><code data-trim data-noescape class="scala">object Hello {
  def print(): Unit = {
    println(&quot;Hello, World!&quot;)
  }
}

Hello.print()  // Hello, World!
// Hello print()
// Hello print

// Application entry point
object Main {
  def main(args: Array[String]): Unit = {
    println(&quot;Hello, World!&quot;)
  }
}</code></pre>
</section>
<section>
<section >
<h2>Advanced Data Types</h2>
<ul class="simple">
<li><p>Tuple</p></li>
<li><p>Case class</p></li>
<li><p>Option type</p></li>
<li><p>Collections</p>
<ul>
<li><p>Sequence: List, Array, Vector</p></li>
<li><p>Set</p></li>
<li><p>Map</p></li>
<li><p>High-order methods of collections</p></li>
</ul>
</li>
</ul>
</section>
<section >
<h3>Tuple</h3>
<ul class="simple">
<li><p>A tuple is a collection of elements of different types</p></li>
<li><p>Tuple is immutable (means its elements cannot be changed)</p></li>
<li><p>Tuple variable can be reassigned</p></li>
<li><p>Access elements using 1-based index</p></li>
</ul>
<pre data-id="tuple"><code data-trim data-noescape class="scala">val t = (1, &quot;Hello&quot;, 3.14)
println(t._1) // 1
println(t._2) // Hello
println(t._3) // 3.14
// t = (2, &quot;World&quot;, 6.28) // Error: t is declared as val
// t._1 = 2 // Error: Tuple is immutable
// println(t._4) // Error: Tuple index out of range

var t1 = (1, &quot;Hello&quot;, 3.14)
t1 = (2, &quot;World&quot;, 6.28)  // allowed</code></pre>
</section>
<section >
<h3>Case Class</h3>
<ul class="simple">
<li><p>A special class with immutable properties and some additional features</p></li>
<li><p>No <code class="docutils literal notranslate"><span class="pre">new</span></code> keyword required to create an instance</p></li>
<li><p>Works like a tuple with all fields named</p></li>
<li><p>Works well with pattern matching</p></li>
</ul>
<pre data-id="case-class"><code data-trim data-noescape class="scala">case class Person(name: String, age: Int)
val p = Person(&quot;Alice&quot;, 25)  // Create an instance without &quot;new&quot; keyword
println(p.name) // Alice
println(p.age) // 25</code></pre>
</section>
<section >
<h3>Collections</h3>
</section>
</section>

        </div>
    </div>
    
    <script src="../_static/revealjs4/dist/reveal.js"></script>
    
    
      <script src="../_static/revealjs4/plugin/notes/notes.js"></script>
      <script src="../_static/revealjs4/plugin/highlight/highlight.js"></script>
      <script src="../_static/revealjs4/plugin/math/math.js"></script>
      
    
    <script>
        var revealjsConfig = new Object();
        Object.assign(revealjsConfig, JSON.parse('{"controls": true, "progress": true, "hash": true, "center": true, "transition": "slide", "slideNumber": true}'));
        
        
        
          revealjsConfig.plugins = [
            RevealNotes,RevealHighlight,RevealMath,
          ];
        
        // More info https://github.com/hakimel/reveal.js#configuration
        Reveal.initialize(revealjsConfig);
    </script>

  </body>
</html>